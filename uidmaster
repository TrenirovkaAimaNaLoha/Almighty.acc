-- Создаем функцию для получения текущего времени в UTC
local function getCurrentUTCTime()
    local date = os.date("!*t")
    return string.format("%04d-%02d-%02d %02d:%02d:%02d", 
        date.year, date.month, date.day, date.hour, date.min, date.sec)
end

-- Функция создания селектора платформы
local function createPlatformSelector()
    local selectionGui = Instance.new("ScreenGui")
    selectionGui.Name = "PlatformSelector"
    selectionGui.ResetOnSpawn = false
    selectionGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Создаем затемненный фон с эффектом размытия
    local backgroundDim = Instance.new("Frame")
    backgroundDim.Name = "BackgroundDim"
    backgroundDim.Size = UDim2.new(1, 0, 1, 0)
    backgroundDim.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    backgroundDim.BackgroundTransparency = 1

    -- Добавляем эффект размытия
    local blur = Instance.new("BlurEffect")
    blur.Size = 0
    blur.Parent = game:GetService("Lighting")
    backgroundDim.Parent = selectionGui

    -- Основной фрейм с градиентом
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    local height = 300 -- Увеличиваем высоту для аватара
    mainFrame.Size = UDim2.new(0, 300, 0, height)
    mainFrame.Position = UDim2.new(0.5, -150, 0.5, -height/2)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 1
    mainFrame.Parent = selectionGui

    -- Добавляем градиент
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(35, 35, 45)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 35))
    })
    gradient.Rotation = 45
    gradient.Parent = mainFrame

    -- Скругление углов
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 8)
    UICorner.Parent = mainFrame

    -- Добавляем изображение персонажа
    local playerImage = Instance.new("ImageLabel")
    playerImage.Name = "PlayerImage"
    playerImage.Size = UDim2.new(0, 100, 0, 100)
    playerImage.Position = UDim2.new(0.5, -50, 0, 20)
    playerImage.BackgroundTransparency = 1
    playerImage.Image = "rbxthumb://type=AvatarHeadShot&id=" .. game.Players.LocalPlayer.UserId .. "&w=100&h=100"
    playerImage.BackgroundTransparency = 1
    playerImage.Parent = mainFrame

    -- Добавляем круглую рамку для аватара
    local imageCorner = Instance.new("UICorner")
    imageCorner.CornerRadius = UDim.new(0.5, 0)
    imageCorner.Parent = playerImage

    -- Добавляем светящийся ободок
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.Size = UDim2.new(1.2, 0, 1.2, 0)
    glow.Position = UDim2.new(-0.1, 0, -0.1, 0)
    glow.BackgroundTransparency = 1
    glow.Image = "rbxassetid://4996891970" -- Изображение свечения
    glow.ImageColor3 = Color3.fromRGB(115, 125, 255)
    glow.ImageTransparency = 1
    glow.Parent = playerImage

    -- Заголовок
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.Position = UDim2.new(0, 0, 0, 130)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Select Method"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 24
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextTransparency = 1
    titleLabel.Parent = mainFrame

    -- Дата и время с иконкой
    local dateTimeFrame = Instance.new("Frame")
    dateTimeFrame.Size = UDim2.new(0.8, 0, 0, 20)
    dateTimeFrame.Position = UDim2.new(0.1, 0, 0, 180)
    dateTimeFrame.BackgroundTransparency = 1
    dateTimeFrame.Parent = mainFrame

    local clockIcon = Instance.new("ImageLabel")
    clockIcon.Size = UDim2.new(0, 16, 0, 16)
    clockIcon.Position = UDim2.new(0, 0, 0, 2)
    clockIcon.BackgroundTransparency = 1
    clockIcon.Image = "rbxassetid://7733993311" -- Иконка часов
    clockIcon.ImageColor3 = Color3.fromRGB(200, 200, 200)
    clockIcon.ImageTransparency = 1
    clockIcon.Parent = dateTimeFrame

    local dateTimeLabel = Instance.new("TextLabel")
    dateTimeLabel.Size = UDim2.new(1, -24, 1, 0)
    dateTimeLabel.Position = UDim2.new(0, 24, 0, 0)
    dateTimeLabel.BackgroundTransparency = 1
    dateTimeLabel.Text = getCurrentUTCTime()
    dateTimeLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    dateTimeLabel.TextSize = 14
    dateTimeLabel.Font = Enum.Font.GothamMedium
    dateTimeLabel.TextTransparency = 1
    dateTimeLabel.Parent = dateTimeFrame

    -- Имя пользователя с иконкой
    local userFrame = Instance.new("Frame")
    userFrame.Size = UDim2.new(0.8, 0, 0, 20)
    userFrame.Position = UDim2.new(0.1, 0, 0, 210)
    userFrame.BackgroundTransparency = 1
    userFrame.Parent = mainFrame

    local userIcon = Instance.new("ImageLabel")
    userIcon.Size = UDim2.new(0, 16, 0, 16)
    userIcon.Position = UDim2.new(0, 0, 0, 2)
    userIcon.BackgroundTransparency = 1
    userIcon.Image = "rbxassetid://7733992783" -- Иконка пользователя
    userIcon.ImageColor3 = Color3.fromRGB(200, 200, 200)
    userIcon.ImageTransparency = 1
    userIcon.Parent = userFrame

    local userLabel = Instance.new("TextLabel")
    userLabel.Size = UDim2.new(1, -24, 1, 0)
    userLabel.Position = UDim2.new(0, 24, 0, -10)
    userLabel.BackgroundTransparency = 1
    userLabel.Text = "User: " .. game.Players.LocalPlayer.Name
    userLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    userLabel.TextSize = 14
    userLabel.Font = Enum.Font.GothamMedium
    userLabel.TextTransparency = 1
    userLabel.Parent = userFrame

    -- Функция создания кнопки с улучшенным дизайном
    local function createButton(text, position)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.8, 0, 0, 40)
        button.Position = position
        button.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
        button.Text = text
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 18
        button.Font = Enum.Font.GothamBold
        button.BackgroundTransparency = 1
        button.TextTransparency = 1
        button.AutoButtonColor = false
        button.Parent = mainFrame
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 6)
        buttonCorner.Parent = button
        
        -- Добавляем градиент для кнопки
        local buttonGradient = Instance.new("UIGradient")
        buttonGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 55)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 45))
        })
        buttonGradient.Rotation = 45
        buttonGradient.Parent = button
        
        -- Добавляем свечение
        local glow = Instance.new("ImageLabel")
        glow.Size = UDim2.new(1.1, 0, 1.1, 0)
        glow.Position = UDim2.new(-0.05, 0, -0.05, 0)
        glow.BackgroundTransparency = 1
        glow.Image = "rbxassetid://4996891970"
        glow.ImageColor3 = Color3.fromRGB(115, 125, 255)
        glow.ImageTransparency = 1
        glow.ZIndex = button.ZIndex - 1
        glow.Parent = button
        
        return button, glow
    end

    -- Создаем кнопки
    local pcButton, pcGlow = createButton("PC Version", UDim2.new(0.1, 0, 0, 220))
    local mobileButton, mobileGlow = createButton("Mobile Version", UDim2.new(0.1, 0, 0, 260))

    -- Анимация появления
    local TweenService = game:GetService("TweenService")
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    -- Анимируем появление всех элементов
    TweenService:Create(blur, tweenInfo, {Size = 20}):Play()
    TweenService:Create(backgroundDim, tweenInfo, {BackgroundTransparency = 0.5}):Play()
    TweenService:Create(mainFrame, tweenInfo, {BackgroundTransparency = 0}):Play()
    TweenService:Create(titleLabel, tweenInfo, {TextTransparency = 0}):Play()
    TweenService:Create(dateTimeLabel, tweenInfo, {TextTransparency = 0}):Play()
    TweenService:Create(userLabel, tweenInfo, {TextTransparency = 0}):Play()
    TweenService:Create(clockIcon, tweenInfo, {ImageTransparency = 0}):Play()
    TweenService:Create(userIcon, tweenInfo, {ImageTransparency = 0}):Play()
    TweenService:Create(playerImage, tweenInfo, {ImageTransparency = 0}):Play()
    TweenService:Create(glow, tweenInfo, {ImageTransparency = 0.7}):Play()

    wait(0.3)

    -- Анимируем появление кнопок
    TweenService:Create(pcButton, tweenInfo, {BackgroundTransparency = 0, TextTransparency = 0}):Play()
    TweenService:Create(mobileButton, tweenInfo, {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    -- Добавляем улучшенные эффекты наведения для кнопок
    local function setupButtonEffects(button, glow)
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(45, 45, 55),
                Size = UDim2.new(0.82, 0, 0, 42) -- Небольшое увеличение размера
            }):Play()
            TweenService:Create(glow, TweenInfo.new(0.2), {
                ImageTransparency = 0.5
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(35, 35, 45),
                Size = UDim2.new(0.8, 0, 0, 40)
            }):Play()
            TweenService:Create(glow, TweenInfo.new(0.2), {
                ImageTransparency = 0.7
            }):Play()
        end)
        
        button.MouseButton1Down:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.1), {
                Size = UDim2.new(0.78, 0, 0, 38)
            }):Play()
        end)
        
        button.MouseButton1Up:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.1), {
                Size = UDim2.new(0.8, 0, 0, 40)
            }):Play()
        end)
    end

    setupButtonEffects(pcButton, pcGlow)
    setupButtonEffects(mobileButton, mobileGlow)

    -- Обработка нажатий на кнопки с улучшенной анимацией
    local function handleButtonClick(button, loadFunction)
        -- Анимация нажатия
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundTransparency = 1,
            TextTransparency = 1
        }):Play()
        
        -- Анимация исчезновения всех элементов
        TweenService:Create(blur, tweenInfo, {Size = 0}):Play()
        TweenService:Create(backgroundDim, tweenInfo, {BackgroundTransparency = 1}):Play()
        TweenService:Create(mainFrame, tweenInfo, {
            BackgroundTransparency = 1,
            Position = UDim2.new(0.5, -150, 0.6, -height/2)
        }):Play()
        
        wait(0.5)
        blur:Destroy()
        selectionGui:Destroy()
        loadFunction()
    end

    pcButton.MouseButton1Click:Connect(function()
        handleButtonClick(pcButton, loadPCVersion)
    end)

    mobileButton.MouseButton1Click:Connect(function()
        handleButtonClick(mobileButton, loadMobileVersion)
    end)

    -- Обновление времени в реальном времени
    spawn(function()
        while wait(1) do
            if dateTimeLabel.Parent then
                dateTimeLabel.Text = getCurrentUTCTime()
            else
                break
            end
        end
    end)
end

-- Функция загрузки PC версии
function loadPCVersion()










































    -- Здесь вставьте ваш основной код меню
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Main UI configuration
local MenuSystem = {
    Tabs = {},
    CurrentTab = nil,
    IsOpen = false,
    ButtonSpacing = 8,
    ButtonHeight = 35,
}

-- Color scheme
-- First modify the Colors definition to be accessible through MenuSystem
MenuSystem.Colors = {
    Background = Color3.fromRGB(25, 25, 35),
    TabBar = Color3.fromRGB(30, 30, 40),
    Button = Color3.fromRGB(35, 35, 45),
    ButtonHover = Color3.fromRGB(45, 45, 55),
    AccentColor = Color3.fromRGB(115, 125, 255),
    TextColor = Color3.fromRGB(255, 255, 255)
}

local Colors = MenuSystem.Colors -- Keep local reference for easier access

-- Create the main frame with rounded corners
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "EnhancedMenu"
screenGui.ResetOnSpawn = false
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 550, 0, 350) -- Изменено с 350 на 500
mainFrame.Position = UDim2.new(0.5, -125, 0.5, -250) -- Изменено положение для центрирования
mainFrame.BackgroundColor3 = Colors.Background
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Visible = true
mainFrame.Parent = screenGui

-- Add rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = mainFrame

-- Add title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Colors.AccentColor
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleUICorner = Instance.new("UICorner")
titleUICorner.CornerRadius = UDim.new(0, 8)
titleUICorner.Parent = titleBar

local titleText = Instance.new("TextLabel")
titleText.Name = "Title"
titleText.Size = UDim2.new(1, -10, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "Almighty.acc"
titleText.TextColor3 = Colors.TextColor
titleText.TextSize = 16
titleText.Font = Enum.Font.GothamBold
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Create tab buttons container
local tabButtons = Instance.new("Frame")
tabButtons.Name = "TabButtons"
tabButtons.Size = UDim2.new(1, 0, 0, 35)
tabButtons.Position = UDim2.new(0, 0, 0, 30)
tabButtons.BackgroundColor3 = Colors.TabBar
tabButtons.BorderSizePixel = 0
tabButtons.Parent = mainFrame

-- Create tab content container
local tabContent = Instance.new("Frame")
tabContent.Name = "TabContent"
tabContent.Size = UDim2.new(1, 0, 1, -65)
tabContent.Position = UDim2.new(0, 0, 0, 65)
tabContent.BackgroundColor3 = Colors.Background
tabContent.BorderSizePixel = 0
tabContent.Parent = mainFrame

-- Function to create a new tab with improved visuals
function MenuSystem.createTab(tabName)
    local tab = {
        Name = tabName,
        Buttons = {},
        Frame = nil,
        ButtonCount = 0
    }
    
    -- Create tab button with improved style
    local tabButton = Instance.new("TextButton")
    tabButton.Name = tabName .. "Button"
    tabButton.Size = UDim2.new(0, 60, 1, -4)
    tabButton.Position = UDim2.new(0, 5 + (#MenuSystem.Tabs * 62), 0, 2)
    tabButton.BackgroundColor3 = Colors.Button
    tabButton.Text = tabName
    tabButton.TextColor3 = Colors.TextColor
    tabButton.Font = Enum.Font.GothamMedium
    tabButton.TextSize = 12
    tabButton.AutoButtonColor = false
    tabButton.Parent = tabButtons

    -- Add rounded corners to tab button
    local tabButtonCorner = Instance.new("UICorner")
    tabButtonCorner.CornerRadius = UDim.new(0, 6)
    tabButtonCorner.Parent = tabButton
    
    -- Create tab content frame with improved scrolling
    local tabFrame = Instance.new("ScrollingFrame")
    tabFrame.Name = tabName .. "Content"
    tabFrame.Size = UDim2.new(1, -10, 1, -10)
    tabFrame.Position = UDim2.new(0, 5, 0, 5)
    tabFrame.BackgroundTransparency = 1
    tabFrame.ScrollBarThickness = 4
    tabFrame.ScrollBarImageColor3 = Colors.AccentColor
    tabFrame.Visible = false
    tabFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    tabFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    tabFrame.ScrollingEnabled = true
    tabFrame.Parent = tabContent
    
    tab.Frame = tabFrame

    -- Улучшенная система прокрутки
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    
    local function updateScrolling()
        local contentSize = 0
        for _, child in ipairs(tabFrame:GetChildren()) do
            if child:IsA("Frame") or child:IsA("TextButton") then
                contentSize = contentSize + child.Size.Y.Offset + 5
            end
        end
        tabFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize + 10)
    end

    tabFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateScrolling)
    tabFrame.ChildAdded:Connect(updateScrolling)
    tabFrame.ChildRemoved:Connect(updateScrolling)

    local function onScroll(input)
        if input.UserInputType == Enum.UserInputType.MouseWheel and tabFrame.Visible then
            local currentScroll = tabFrame.CanvasPosition.Y
            local maxScroll = math.max(0, tabFrame.AbsoluteCanvasSize.Y - tabFrame.AbsoluteSize.Y)
            local scrollStep = 80 * -input.Position.Z
            
            local targetScroll = math.clamp(currentScroll + scrollStep, 0, maxScroll)
            
            TweenService:Create(tabFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                CanvasPosition = Vector2.new(0, targetScroll)
            }):Play()
        end
    end

    UserInputService.InputChanged:Connect(onScroll)

    -- Остальной код без изменений
    tabButton.MouseEnter:Connect(function()
        if MenuSystem.CurrentTab ~= tabName then
            TweenService:Create(tabButton, TweenInfo.new(0.2), {
                BackgroundColor3 = Colors.ButtonHover
            }):Play()
        end
    end)
    
    tabButton.MouseLeave:Connect(function()
        if MenuSystem.CurrentTab ~= tabName then
            TweenService:Create(tabButton, TweenInfo.new(0.2), {
                BackgroundColor3 = Colors.Button
            }):Play()
        end
    end)
    
    tabButton.MouseButton1Click:Connect(function()
        MenuSystem.switchTab(tabName)
    end)
    
    table.insert(MenuSystem.Tabs, tab)
    if #MenuSystem.Tabs == 1 then
        MenuSystem.switchTab(tabName)
    end
    
    return tab
end











-- Enhanced tab switching with animations
function MenuSystem.switchTab(tabName)
    for _, tab in ipairs(MenuSystem.Tabs) do
        local isSelected = (tab.Name == tabName)
        local tabButton = tabButtons:FindFirstChild(tab.Name .. "Button")
        
        if tabButton then
            TweenService:Create(tabButton, TweenInfo.new(0.2), {
                BackgroundColor3 = isSelected and Colors.AccentColor or Colors.Button
            }):Play()
        end
        
        if tab.Frame then
            if isSelected then
                tab.Frame.Visible = true
                tab.Frame.Position = UDim2.new(0, 5, 0, 15)
                tab.Frame.BackgroundTransparency = 1
                TweenService:Create(tab.Frame, TweenInfo.new(0.2), {
                    Position = UDim2.new(0, 5, 0, 5),
                    BackgroundTransparency = 1
                }):Play()
            else
                tab.Frame.Visible = false
            end
        end
    end
    MenuSystem.CurrentTab = tabName
end

-- Enhanced button creation with improved visuals and auto-sizing background
function MenuSystem.createButton(tabName, position, text, callback)
    -- Store keybinds globally
    if not MenuSystem.Keybinds then
        MenuSystem.Keybinds = {}
    end

    for _, tab in ipairs(MenuSystem.Tabs) do
        if tab.Name == tabName then
            tab.ButtonCount = tab.ButtonCount + 1
            
            -- Create container frame for auto-sizing
            local buttonContainer = Instance.new("Frame")
            buttonContainer.Name = "ButtonContainer_" .. tab.ButtonCount
            buttonContainer.BackgroundTransparency = 1
            buttonContainer.Size = UDim2.new(0.95, 0, 0, MenuSystem.ButtonHeight)
            buttonContainer.Position = UDim2.new(0.025, 0, 0, (position - 1) * (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing))
            buttonContainer.Parent = tab.Frame
            
            -- Create text label to measure text size
            local textLabel = Instance.new("TextLabel")
            textLabel.Text = text or "Button " .. tab.ButtonCount
            textLabel.BackgroundTransparency = 1
            textLabel.Font = Enum.Font.GothamMedium
            textLabel.TextSize = 14
            textLabel.Size = UDim2.new(0, 1000, 0, MenuSystem.ButtonHeight)
            textLabel.TextXAlignment = Enum.TextXAlignment.Left
            textLabel.Parent = buttonContainer
            
            task.wait()
            
            local textWidth = textLabel.TextBounds.X
            local buttonWidth = textWidth + 20
            
            local button = Instance.new("TextButton")
            button.Name = "Button_" .. tab.ButtonCount
            button.Size = UDim2.new(0, buttonWidth, 1, 0)
            button.Position = UDim2.new(0, 0, 0, 0)
            button.BackgroundColor3 = Colors.Button
            button.Text = text or "Button " .. tab.ButtonCount
            button.TextColor3 = Colors.TextColor
            button.Font = Enum.Font.GothamMedium
            button.TextSize = 14
            button.AutoButtonColor = false
            button.Parent = buttonContainer
            button.TextXAlignment = Enum.TextXAlignment.Left

            local originalText = button.Text
            
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 10)
            padding.Parent = button
            
            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 6)
            buttonCorner.Parent = button
            
            textLabel:Destroy()

            -- Keybind handling
            local currentKeybind = nil
            local waitingForBind = false

            -- Store button reference in global keybinds table
            MenuSystem.Keybinds[button] = {
                originalText = originalText,
                currentKeybind = nil,
                reset = function()
                    currentKeybind = nil
                    button.Text = originalText
                    button.TextColor3 = Colors.TextColor
                    MenuSystem.showNotification(
                        "Keybind Reset",
                        "Removed keybind for " .. originalText,
                        "info"
                    )
                end
            }

            -- Right click to start binding or reset if in Keybinds tab
            button.MouseButton2Click:Connect(function()
                if tab.Name == "Keybinds" then
                    -- If in Keybinds tab, find and reset the corresponding button
                    for btn, data in pairs(MenuSystem.Keybinds) do
                        if btn.Text == button.Text and data.currentKeybind then
                            data.reset()
                            -- Remove this button from Keybinds tab
                            button:Destroy()
                            -- Reposition remaining buttons
                            local yPosition = 0
                            for _, child in ipairs(tab.Frame:GetChildren()) do
                                if child:IsA("TextButton") then
                                    child.Position = UDim2.new(0.025, 0, 0, yPosition)
                                    yPosition = yPosition + (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing)
                                end
                            end
                            -- Update canvas size
                            tab.ButtonCount = tab.ButtonCount - 1
                            tab.Frame.CanvasSize = UDim2.new(0, 0, 0, tab.ButtonCount * (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing))
                            break
                        end
                    end
                else
                    waitingForBind = true
                    button.Text = "Press any key..."
                    button.TextColor3 = Color3.fromRGB(255, 255, 0)
                end
            end)

            -- Listen for key press
            UserInputService.InputBegan:Connect(function(input)
                if waitingForBind then
                    if input.UserInputType == Enum.UserInputType.Keyboard then
                        currentKeybind = input.KeyCode
                        MenuSystem.Keybinds[button].currentKeybind = currentKeybind
                        waitingForBind = false
                        button.Text = originalText .. " [" .. input.KeyCode.Name .. "]"
                        button.TextColor3 = Colors.TextColor
                        
                        -- Create or update keybind button in Keybinds tab
                        local keybindButton = nil
                        for _, tab in ipairs(MenuSystem.Tabs) do
                            if tab.Name == "Keybinds" then
                                keybindButton = MenuSystem.createButton("Keybinds", tab.ButtonCount + 1, button.Text, function()
                                    -- Reset keybind when clicked in Keybinds tab
                                    MenuSystem.Keybinds[button].reset()
                                    -- Remove this button
                                    keybindButton:Destroy()
                                    -- Reposition remaining buttons
                                    local yPosition = 0
                                    for _, child in ipairs(tab.Frame:GetChildren()) do
                                        if child:IsA("TextButton") then
                                            child.Position = UDim2.new(0.025, 0, 0, yPosition)
                                            yPosition = yPosition + (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing)
                                        end
                                    end
                                    -- Update canvas size
                                    tab.ButtonCount = tab.ButtonCount - 1
                                    tab.Frame.CanvasSize = UDim2.new(0, 0, 0, tab.ButtonCount * (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing))
                                end)
                                break
                            end
                        end
                        
                        MenuSystem.showNotification(
                            "Keybind Set",
                            "Bound " .. originalText .. " to " .. input.KeyCode.Name,
                            "success"
                        )
                    end
                else
                    if currentKeybind and input.KeyCode == currentKeybind then
                        if callback then
                            callback()
                        end
                    end
                end
            end)
            
            -- Enhanced hover effects
            button.MouseEnter:Connect(function()
                if not waitingForBind then
                    TweenService:Create(button, TweenInfo.new(0.2), {
                        BackgroundColor3 = Colors.ButtonHover
                    }):Play()
                end
            end)
            
            button.MouseLeave:Connect(function()
                if not waitingForBind then
                    TweenService:Create(button, TweenInfo.new(0.2), {
                        BackgroundColor3 = Colors.Button
                    }):Play()
                end
            end)
            
            -- Click effects
            button.MouseButton1Down:Connect(function()
                if not waitingForBind then
                    TweenService:Create(button, TweenInfo.new(0.1), {
                        Size = UDim2.new(0, buttonWidth * 0.98, 1, -2)
                    }):Play()
                end
            end)
            
            button.MouseButton1Up:Connect(function()
                if not waitingForBind then
                    TweenService:Create(button, TweenInfo.new(0.1), {
                        Size = UDim2.new(0, buttonWidth, 1, 0)
                    }):Play()
                end
            end)
            
            if callback then
                button.MouseButton1Click:Connect(function()
                    if not waitingForBind then
                        callback()
                    end
                end)
            end
            
            tab.Frame.CanvasSize = UDim2.new(0, 0, 0, tab.ButtonCount * (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing))
            
            return button
        end
    end
end

-- Create Keybinds tab
local keybindsTab = MenuSystem.createTab("Keybinds")

-- Toggle menu visibility with animation
function MenuSystem.toggleMenu()
    MenuSystem.IsOpen = not MenuSystem.IsOpen
    if MenuSystem.IsOpen then
        mainFrame.Visible = true
        mainFrame.Transparency = 1
        TweenService:Create(mainFrame, TweenInfo.new(0.2), {
            Transparency = 0
        }):Play()
    else
        TweenService:Create(mainFrame, TweenInfo.new(0.2), {
            Transparency = 1
        }):Play()
        wait(0.2)
        mainFrame.Visible = false
    end
end

-- Handle Insert key press
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.Insert then
        MenuSystem.toggleMenu()
    end
end)

-- Create default tabs
local gameTab = MenuSystem.createTab("Game")
local visibleTab = MenuSystem.createTab("Visible")
local miscTab = MenuSystem.createTab("Misc")
local optionsTab = MenuSystem.createTab("Options")

function MenuSystem.deleteGUI()
    if screenGui then
        screenGui:Destroy()
    end
    
    -- Очистка всех соединений и данных
    MenuSystem.Tabs = {}
    MenuSystem.CurrentTab = nil
    MenuSystem.IsOpen = false
    
    -- Отключение обработчика клавиши Insert
    for _, connection in pairs(getconnections(UserInputService.InputBegan)) do
        if connection.Function and tostring(connection.Function):find("Insert") then
            connection:Disconnect()
        end
    end
end

-- В конце скрипта, после создания табов, добавьте кнопку Delete GUI
MenuSystem.createButton("Options", 1, "Delete GUI", function()
    -- Отключаем все функции перед удалением
    
    -- Отключаем ESP если включен
    if MenuSystem.wallhackEnabled then
        MenuSystem.toggleESP()
    end
    
    -- Отключаем Noclip если включен  
    if MenuSystem.noclipEnabled then
        MenuSystem.toggleNoclip()
    end
    
    -- Отключаем все соединения и события
    if MenuSystem.noclipConnection then
        MenuSystem.noclipConnection:Disconnect()
    end
    
    -- Очищаем ESP объекты
    for player, objects in pairs(MenuSystem.espObjects) do
        MenuSystem.removePlayerESP(player)
    end
    
    -- Восстанавливаем настройки освещения
    local lighting = game:GetService("Lighting")
    pcall(function()
        lighting.GlobalShadows = true
        lighting.Brightness = 1
    end)
    
    -- Очищаем все уведомления
    for _, notification in ipairs(MenuSystem.notifications.active) do
        if notification and notification.Parent then
            notification:Destroy() 
        end
    end
    
    -- Анимация исчезновения
    local fadeOut = TweenService:Create(mainFrame, TweenInfo.new(0.5), {
        Transparency = 1,
        Position = UDim2.new(0.5, -125, 1.5, 0)
    })
    
    fadeOut:Play()
    fadeOut.Completed:Connect(function()
        -- Удаляем GUI и очищаем данные
        MenuSystem.deleteGUI()
        MenuSystem.notifications = {queue = {}, active = {}, isProcessing = false}
        MenuSystem.espObjects = {}
        MenuSystem.Settings = nil
        MenuSystem.ESP_CONFIG = nil
        MenuSystem = nil
    end)
    
    -- Показываем финальное уведомление
    MenuSystem.showNotification(
        "GUI Deleted",
        "All features have been disabled and removed",
        "info"
    )
end)

















-- Добавляем необходимые сервисы в начало скрипта
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Добавляем конфигурацию ESP в MenuSystem
MenuSystem.ESP_CONFIG = {
    HIGHLIGHT_COLOR = Color3.fromRGB(136, 155, 155),
    TEXT_COLOR = Color3.fromRGB(136, 155, 155),
    TEXT_STROKE_COLOR = Color3.fromRGB(0, 0, 0),
    TEXT_SIZE = 15,
    BILLBOARD_OFFSET = Vector3.new(0, 2.5, 0)
}

-- Создаем хранилище для объектов ESP
MenuSystem.espObjects = {}
MenuSystem.wallhackEnabled = false

-- Функции ESP
function MenuSystem.createPlayerESP(player)
    if player == LocalPlayer then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Create highlight
    local highlight = Instance.new("Highlight")
    highlight.FillColor = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR
    highlight.OutlineColor = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR
    highlight.FillTransparency = 0.4
    highlight.OutlineTransparency = 0
    highlight.Parent = character
    
    -- Create BillboardGui for name
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPBillboard"
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = MenuSystem.ESP_CONFIG.BILLBOARD_OFFSET
    billboard.AlwaysOnTop = true
    billboard.Parent = character:WaitForChild("HumanoidRootPart")
    
    -- Create name label
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = string.format("%s [ %dhp ]", player.Name, humanoid.Health)
    nameLabel.TextColor3 = MenuSystem.ESP_CONFIG.TEXT_COLOR
    nameLabel.TextStrokeColor3 = MenuSystem.ESP_CONFIG.TEXT_STROKE_COLOR
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextSize = MenuSystem.ESP_CONFIG.TEXT_SIZE
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.Parent = billboard
    
    -- Connect health changed event
    local healthChanged = humanoid.HealthChanged:Connect(function(health)
        if nameLabel then
            nameLabel.Text = string.format("%s [ %dhp ]", player.Name, health)
        end
    end)
    
    MenuSystem.espObjects[player] = {
        highlight = highlight,
        billboard = billboard,
        healthConnection = healthChanged
    }
end

function MenuSystem.removePlayerESP(player)
    local objects = MenuSystem.espObjects[player]
    if objects then
        if objects.highlight then objects.highlight:Destroy() end
        if objects.billboard then objects.billboard:Destroy() end
        if objects.healthConnection then objects.healthConnection:Disconnect() end
        MenuSystem.espObjects[player] = nil
    end
end

function MenuSystem.toggleESP()
    MenuSystem.wallhackEnabled = not MenuSystem.wallhackEnabled
    
    -- Show notification for ESP toggle
    MenuSystem.showNotification(
        "ESP " .. (MenuSystem.wallhackEnabled and "Enabled" or "Disabled"),
        MenuSystem.wallhackEnabled and "ESP features are now active" or "ESP features have been disabled",
        MenuSystem.wallhackEnabled and "success" or "info"
    )
    
    if MenuSystem.wallhackEnabled then
        -- Set up ESP for existing players
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                MenuSystem.createPlayerESP(player)
            end
        end
        
        -- Connect player events
        Players.PlayerAdded:Connect(function(player)
            if MenuSystem.wallhackEnabled then
                MenuSystem.showNotification(
                    "Player Joined",
                    player.Name .. " has joined the game",
                    "info"
                )
                player.CharacterAdded:Connect(function()
                    if MenuSystem.wallhackEnabled then
                        wait(0.5)
                        MenuSystem.createPlayerESP(player)
                    end
                end)
            end
        end)
        
        Players.PlayerRemoving:Connect(function(player)
            MenuSystem.removePlayerESP(player)
            MenuSystem.showNotification(
                "Player Left",
                player.Name .. " has left the game",
                "warning"
            )
        end)
        
        -- Handle respawning
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                player.CharacterAdded:Connect(function()
                    if MenuSystem.wallhackEnabled then
                        wait(0.5)
                        MenuSystem.createPlayerESP(player)
                    end
                end)
            end
        end
        
        -- Update ESP
        RunService.RenderStepped:Connect(function()
            if not MenuSystem.wallhackEnabled then return end
            
            for player, objects in pairs(MenuSystem.espObjects) do
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                    MenuSystem.removePlayerESP(player)
                end
            end
        end)
    else
        -- Clean up ESP objects
        for player, _ in pairs(MenuSystem.espObjects) do
            MenuSystem.removePlayerESP(player)
        end
        
        MenuSystem.showNotification(
            "ESP Cleanup",
            "All ESP elements have been removed",
            "info"
        )
    end
end


    



function MenuSystem.formatTimeDisplay()
    local date = os.date("!*t")
    return string.format("%02d:%02d:%02d UTC", date.hour, date.min, date.sec)
end

function MenuSystem.createSessionInfo()
    -- Create container frame
    local container = Instance.new("Frame")
    container.Name = "SessionContainer" 
    container.Size = UDim2.new(0, 200, 0, 60)
    container.Position = UDim2.new(1, -200, 0, 295)
    container.BackgroundTransparency = 1
    container.Parent = mainFrame

    -- Create player image
    local playerImage = Instance.new("ImageLabel")
    playerImage.Name = "PlayerImage"
    playerImage.Size = UDim2.new(0, 40, 0, 40)
    playerImage.Position = UDim2.new(1, -45, 0, 10)
    playerImage.BackgroundTransparency = 0
    playerImage.Image = "rbxthumb://type=AvatarHeadShot&id=" .. game.Players.LocalPlayer.UserId .. "&w=100&h=100"
    playerImage.Parent = container

    -- Add rounded corners to image
    local imageCorner = Instance.new("UICorner")
    imageCorner.CornerRadius = UDim.new(0.5, 0)
    imageCorner.Parent = playerImage
    
    -- Add glow effect
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.Size = UDim2.new(1.2, 0, 1.2, 0)
    glow.Position = UDim2.new(-0.1, 0, -0.1, 0)
    glow.BackgroundTransparency = 1
    glow.Image = "rbxassetid://4996891970"
    glow.ImageColor3 = Color3.fromRGB(115, 125, 255)
    glow.ImageTransparency = 0.7
    glow.Parent = playerImage

    -- Create session info text
    local sessionLabel = Instance.new("TextLabel")
    sessionLabel.Name = "SessionInfo"
    sessionLabel.Size = UDim2.new(0, 150, 0, 40)
    sessionLabel.Position = UDim2.new(0, 0, 0, 10)
    sessionLabel.BackgroundTransparency = 1
    sessionLabel.Font = Enum.Font.GothamMedium
    sessionLabel.TextSize = 14
    sessionLabel.TextColor3 = Color3.fromRGB(222, 222, 222)
    sessionLabel.TextXAlignment = Enum.TextXAlignment.Left
    sessionLabel.Parent = container
    
    -- Update time every second
    game:GetService("RunService").Heartbeat:Connect(function()
        if sessionLabel and sessionLabel.Parent then
            local userInfo = game.Players.LocalPlayer.Name
            local timeInfo = MenuSystem.formatTimeDisplay()
            sessionLabel.Text = string.format("User: %s\nTime: %s", userInfo, timeInfo)
        end
    end)
    
    return container, sessionLabel, playerImage
end

-- Call this after creating mainFrame
MenuSystem.sessionContainer, MenuSystem.sessionLabel, MenuSystem.playerImage = MenuSystem.createSessionInfo()

function MenuSystem.createInfoPanel()
    if not MenuSystem.infoPanel then
        MenuSystem.infoPanel = Instance.new("Frame")
        MenuSystem.infoPanel.Size = UDim2.new(0.95, 0, 0, 60)
        MenuSystem.infoPanel.Position = UDim2.new(0.025, 0, 0.9, 0)
        MenuSystem.infoPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        MenuSystem.infoPanel.BorderSizePixel = 0
        MenuSystem.infoPanel.Parent = screenGui

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = MenuSystem.infoPanel

        MenuSystem.sessionLabel = Instance.new("TextLabel")
        MenuSystem.sessionLabel.Size = UDim2.new(1, -20, 1, 0)
        MenuSystem.sessionLabel.Position = UDim2.new(0, 10, 0, 0)
        MenuSystem.sessionLabel.BackgroundTransparency = 1
        MenuSystem.sessionLabel.Font = Enum.Font.GothamMedium
        MenuSystem.sessionLabel.TextSize = 14
        MenuSystem.sessionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        MenuSystem.sessionLabel.TextXAlignment = Enum.TextXAlignment.Left
        MenuSystem.sessionLabel.TextYAlignment = Enum.TextYAlignment.Center
        MenuSystem.sessionLabel.Parent = MenuSystem.infoPanel
    end
    
    -- Обновляем информацию каждую секунду
    if not MenuSystem.updateConnection then
        MenuSystem.updateConnection = game:GetService("RunService").Heartbeat:Connect(function()
            MenuSystem.updateSessionInfo()
        end)
    end
end

function MenuSystem.cleanup()
    if MenuSystem.updateConnection then
        MenuSystem.updateConnection:Disconnect()
        MenuSystem.updateConnection = nil
    end
    
    if MenuSystem.infoPanel then
        MenuSystem.infoPanel:Destroy()
        MenuSystem.infoPanel = nil
    end
end

-- Функция для создания Color Picker
function MenuSystem.createColorPicker()
    local colorPickerGui = Instance.new("Frame")
    colorPickerGui.Name = "ColorPicker"
    colorPickerGui.Size = UDim2.new(0, 200, 0, 160)
    colorPickerGui.Position = UDim2.new(1.1, 0, 0, 0)
    colorPickerGui.BackgroundColor3 = Colors.Background
    colorPickerGui.Visible = false
    colorPickerGui.Parent = mainFrame
    
    local colorPickerCorner = Instance.new("UICorner")
    colorPickerCorner.CornerRadius = UDim.new(0, 6)
    colorPickerCorner.Parent = colorPickerGui
    
    -- RGB Sliders
    local function createSlider(name, position, initialValue)
        local slider = Instance.new("Frame")
        slider.Name = name .. "Slider"
        slider.Size = UDim2.new(0.9, 0, 0, 20)
        slider.Position = UDim2.new(0.05, 0, position, 0)
        slider.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        slider.Parent = colorPickerGui
        
        local sliderCorner = Instance.new("UICorner")
        sliderCorner.CornerRadius = UDim.new(0, 4)
        sliderCorner.Parent = slider
        
        local sliderButton = Instance.new("TextButton")
        sliderButton.Size = UDim2.new(initialValue/255, 0, 1, 0)
        sliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        sliderButton.Text = ""
        sliderButton.Parent = slider
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 4)
        buttonCorner.Parent = sliderButton
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0, 50, 0, 20)
        label.Position = UDim2.new(0, -55, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Colors.TextColor
        label.TextSize = 14
        label.Font = Enum.Font.GothamMedium
        label.Parent = slider
        
        return sliderButton
    end
    
    local rSlider = createSlider("R", 0.1, MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.R * 255)
    local gSlider = createSlider("G", 0.4, MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.G * 255)
    local bSlider = createSlider("B", 0.7, MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.B * 255)
    
    local function updateColor()
        local newColor = Color3.new(
            rSlider.Size.X.Scale,
            gSlider.Size.X.Scale,
            bSlider.Size.X.Scale
        )
        
        MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR = newColor
        MenuSystem.ESP_CONFIG.TEXT_COLOR = newColor
        
        -- Update existing ESP objects
        for _, objects in pairs(MenuSystem.espObjects) do
            if objects.highlight then
                objects.highlight.FillColor = newColor
                objects.highlight.OutlineColor = newColor
            end
            if objects.billboard then
                local nameLabel = objects.billboard:FindFirstChild("TextLabel")
                if nameLabel then
                    nameLabel.TextColor3 = newColor
                end
            end
        end

        -- Show notification when color is updated
        MenuSystem.showNotification(
            "Color Updated",
            string.format("ESP color changed to RGB(%d, %d, %d)", 
                math.floor(newColor.R * 255),
                math.floor(newColor.G * 255), 
                math.floor(newColor.B * 255)),
            "success"
        )
    end
    
    -- Add drag functionality to sliders
    local function makeDraggable(slider)
        local dragging = false
        local lastUpdate = 0
        local updateDelay = 0.1 -- Delay between notifications in seconds
        
        slider.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
            end
        end)
        
        slider.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                updateColor()
            end
        end)
        
        slider.Parent.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                local relativeX = math.clamp((input.Position.X - slider.Parent.AbsolutePosition.X) / slider.Parent.AbsoluteSize.X, 0, 1)
                slider.Size = UDim2.new(relativeX, 0, 1, 0)
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local relativeX = math.clamp((input.Position.X - slider.Parent.AbsolutePosition.X) / slider.Parent.AbsoluteSize.X, 0, 1)
                slider.Size = UDim2.new(relativeX, 0, 1, 0)
                
                -- Update notification with delay
                local currentTime = tick()
                if currentTime - lastUpdate >= updateDelay then
                    lastUpdate = currentTime
                    MenuSystem.showNotification(
                        "Adjusting Color",
                        "Drag slider to adjust ESP color",
                        "info"
                    )
                end
            end
        end)
    end
    
    makeDraggable(rSlider)
    makeDraggable(gSlider)
    makeDraggable(bSlider)

    -- Show notification when color picker is opened/closed
    colorPickerGui:GetPropertyChangedSignal("Visible"):Connect(function()
        if colorPickerGui.Visible then
            MenuSystem.showNotification(
                "Color Picker Opened",
                "Adjust the RGB sliders to change ESP colors",
                "info"
            )
        else
            MenuSystem.showNotification(
                "Color Picker Closed",
                "ESP color settings saved",
                "success"
            )
        end
    end)
    
    return colorPickerGui
end

-- Создаем кнопки в Visuals табе
MenuSystem.createButton("Visible", 1, "Enable ESP", function()
    MenuSystem.toggleESP()
end)

local colorPicker = MenuSystem.createColorPicker()
MenuSystem.createButton("Visible", 2, "Change Colors", function()
    colorPicker.Visible = not colorPicker.Visible
end)

-- Обновляем функцию удаления GUI

-- Обновляем функцию удаления GUI
local oldDeleteGUI = MenuSystem.deleteGUI
MenuSystem.deleteGUI = function()
    -- Отключаем Noclip перед удалением
    if MenuSystem.noclipConnection then
        MenuSystem.noclipConnection:Disconnect()
        MenuSystem.noclipConnection = nil
    end
    
    -- Восстанавливаем коллизии
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    MenuSystem.noclipEnabled = false
    
    -- Вызываем оригинальную функцию удаления
    oldDeleteGUI()
end

-- Функция оптимизации
function MenuSystem.optimizeGame()
    local workspace = game:GetService("Workspace")
    
    -- Функция для удаления объектов по их типу
    local function removeObjectsByType(parent, objectType)
        for _, obj in ipairs(parent:GetDescendants()) do
            if obj:IsA(objectType) then
                obj:Destroy()
            end
        end
    end
    
    -- Список типов объектов для удаления
    local objectTypes = {
        "ParticleEmitter",
        "Trail",
        "PointLight",
        "SpotLight",
        "SurfaceLight",
        "Decal",
        "Texture"
    }
    
    -- Удаляем объекты
    for _, objectType in ipairs(objectTypes) do
        removeObjectsByType(workspace, objectType)
    end
end



-- Обновляем функцию удаления GUI, чтобы отключить Noclip
local oldDeleteGUI = MenuSystem.deleteGUI
MenuSystem.deleteGUI = function()
    -- Отключаем Noclip перед удалением
    if MenuSystem.noclipConnection then
        MenuSystem.noclipConnection:Disconnect()
    end
    MenuSystem.noclipEnabled = false
    
    -- Вызываем оригинальную функцию удаления
    oldDeleteGUI()
end

-- Добавляем систему уведомлений в MenuSystem
MenuSystem.notifications = {
    queue = {},
    isProcessing = false
}

function MenuSystem.createNotification(title, message, type)
    -- Создаем уведомление
    local notification = Instance.new("Frame")
    notification.Name = "Notification"
    notification.Size = UDim2.new(0, 250, 0, 80)
    notification.Position = UDim2.new(1, 20, 0.8, 0) -- Начальная позиция за пределами экрана
    notification.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    notification.BorderSizePixel = 0
    notification.Parent = screenGui

    -- Добавляем скругление углов
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notification

    -- Добавляем цветную полоску слева в зависимости от типа уведомления
    local colorBar = Instance.new("Frame")
    colorBar.Size = UDim2.new(0, 4, 1, 0)
    colorBar.Position = UDim2.new(0, 0, 0, 0)
    colorBar.BorderSizePixel = 0
    
    -- Устанавливаем цвет в зависимости от типа
    if type == "success" then
        colorBar.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
    elseif type == "error" then
        colorBar.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
    elseif type == "warning" then
        colorBar.BackgroundColor3 = Color3.fromRGB(241, 196, 15)
    else
        colorBar.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
    end
    
    colorBar.Parent = notification

    -- Заголовок уведомления
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, -20, 0, 25)
    titleLabel.Position = UDim2.new(0, 15, 0, 5)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 16
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = notification

    -- Текст уведомления
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Size = UDim2.new(1, -20, 0, 40)
    messageLabel.Position = UDim2.new(0, 15, 0, 30)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Text = message
    messageLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    messageLabel.TextSize = 14
    messageLabel.Font = Enum.Font.GothamMedium
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextWrapped = true
    messageLabel.Parent = notification

    -- Добавляем тень
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.Size = UDim2.new(1.1, 0, 1.1, 0)
    shadow.ZIndex = -1
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.Parent = notification

    return notification
end

-- КНОПКИ 

-- Добавляем необходимые переменные в MenuSystem

-- Обновляем создание кнопки Noclip
MenuSystem.createButton("Misc", 1, "Noclip", function()
    MenuSystem.toggleNoclip()
end)

-- Функция получения текущей даты и времени в UTC
function MenuSystem.getCurrentUTCTime()
    local date = os.date("!*t")
    return string.format("%04d-%02d-%02d %02d:%02d:%02d", 
        date.year, date.month, date.day, date.hour, date.min, date.sec)
end

-- Система уведомлений
MenuSystem.notifications = {
    queue = {},
    isProcessing = false,
    active = {}  -- Хранение активных уведомлений
}

function MenuSystem.createNotification(title, message, type)
    local notification = Instance.new("Frame")
    notification.Name = "Notification"
    notification.Size = UDim2.new(0, 250, 0, 80)
    notification.Position = UDim2.new(1, 20, 0.8, 0)
    notification.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    notification.BorderSizePixel = 0
    notification.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notification

    local colorBar = Instance.new("Frame")
    colorBar.Size = UDim2.new(0, 4, 1, 0)
    colorBar.BorderSizePixel = 0
    
    -- Определение цвета уведомления
    local colors = {
        success = Color3.fromRGB(46, 204, 113),
        error = Color3.fromRGB(231, 76, 60),
        warning = Color3.fromRGB(241, 196, 15),
        info = Color3.fromRGB(52, 152, 219)
    }
    colorBar.BackgroundColor3 = colors[type] or colors.info
    colorBar.Parent = notification

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, -20, 0, 25)
    titleLabel.Position = UDim2.new(0, 15, 0, 5)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 16
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = notification

    local messageLabel = Instance.new("TextLabel")
    messageLabel.Size = UDim2.new(1, -20, 0, 40)
    messageLabel.Position = UDim2.new(0, 15, 0, 30)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Text = message
    messageLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    messageLabel.TextSize = 14
    messageLabel.Font = Enum.Font.GothamMedium
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextWrapped = true
    messageLabel.Parent = notification

    return notification
end

function MenuSystem.showNotification(title, message, type)
    table.insert(MenuSystem.notifications.queue, {
        title = title,
        message = message,
        type = type
    })

    if not MenuSystem.notifications.isProcessing then
        MenuSystem.processNotificationQueue()
    end
end

function MenuSystem.processNotificationQueue()
    if #MenuSystem.notifications.queue == 0 then
        MenuSystem.notifications.isProcessing = false
        return
    end

    MenuSystem.notifications.isProcessing = true
    local notificationInfo = table.remove(MenuSystem.notifications.queue, 1)
    local notification = MenuSystem.createNotification(
        notificationInfo.title,
        notificationInfo.message,
        notificationInfo.type
    )

    -- Сохраняем уведомление в активных
    table.insert(MenuSystem.notifications.active, notification)

    -- Анимация появления
    local tweenService = game:GetService("TweenService")
    local appearTween = tweenService:Create(notification, 
        TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Position = UDim2.new(1, -270, 0.8, 0)}
    )
    appearTween:Play()

    task.delay(3, function()
        -- Проверяем, существует ли ещё уведомление
        if notification and notification.Parent then
            -- Анимация исчезновения
            local disappearTween = tweenService:Create(notification,
                TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                {Position = UDim2.new(1, 20, 0.8, 0)}
            )
            disappearTween:Play()

            disappearTween.Completed:Connect(function()
                -- Удаляем уведомление из активных
                for i, activeNotif in ipairs(MenuSystem.notifications.active) do
                    if activeNotif == notification then
                        table.remove(MenuSystem.notifications.active, i)
                        break
                    end
                end
                notification:Destroy()
                -- Обрабатываем следующее уведомление
                MenuSystem.processNotificationQueue()
            end)
        end
    end)
end

-- Обновленная функция toggleNoclip
function MenuSystem.toggleNoclip()
    -- Сохраняем предыдущее состояние для правильного уведомления
    local wasEnabled = MenuSystem.noclipEnabled
    
    -- Переключаем состояние
    MenuSystem.noclipEnabled = not MenuSystem.noclipEnabled
    
    -- Получаем персонажа
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Отключаем предыдущее соединение
    if MenuSystem.noclipConnection then
        MenuSystem.noclipConnection:Disconnect()
        MenuSystem.noclipConnection = nil
    end
    
    -- Функция для установки CanCollide
    local function setCanCollide(char, state)
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = state
                end
            end
        end
    end
    
    if MenuSystem.noclipEnabled then
        -- Создаем новое соединение для Noclip
        MenuSystem.noclipConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if character and character:FindFirstChild("Humanoid") then
                setCanCollide(character, false)
            end
        end)
        
        -- Показываем уведомление о включении
        MenuSystem.showNotification(
            "Noclip Enabled",
            "Press X to toggle Noclip",
            "success"
        )
    else
        -- Восстанавливаем коллизии с небольшой задержкой
        task.spawn(function()
            task.wait(0.1)
            if character and character:FindFirstChild("Humanoid") then
                setCanCollide(character, true)
            end
        end)
        
        -- Показываем уведомление о выключении
        MenuSystem.showNotification(
            "Noclip Disabled",
            "Collisions restored",
            "info"
        )
    end
    
    -- Обновляем текст кнопки
    local button = MenuSystem.Tabs[3].Frame:FindFirstChild("Button_1")
    if button then
        button.Text = "Noclip " .. (MenuSystem.noclipEnabled and "(ON)" or "(OFF)")
    end
    
    -- Обработчик для нового персонажа
    local function onCharacterAdded(newCharacter)
        character = newCharacter
        task.wait(0.1)
        
        if MenuSystem.noclipEnabled and MenuSystem.noclipConnection then
            setCanCollide(character, false)
        end
    end
    
    -- Удаляем предыдущий обработчик, если он существует
    if MenuSystem.characterAddedConnection then
        MenuSystem.characterAddedConnection:Disconnect()
    end
    
    -- Создаем новый обработчик
    MenuSystem.characterAddedConnection = player.CharacterAdded:Connect(onCharacterAdded)
end

-- Обновленная функция очистки при удалении GUI
function MenuSystem.deleteGUI()
    -- Отключаем Noclip
    if MenuSystem.noclipConnection then
        MenuSystem.noclipConnection:Disconnect()
        MenuSystem.noclipConnection = nil
    end
    
    -- Восстанавливаем коллизии
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    -- Удаляем все активные уведомления
    for _, notification in ipairs(MenuSystem.notifications.active) do
        if notification and notification.Parent then
            notification:Destroy()
        end
    end
    
    MenuSystem.notifications.active = {}
    MenuSystem.notifications.queue = {}
    MenuSystem.notifications.isProcessing = false
    MenuSystem.noclipEnabled = false
    
    if screenGui then
        screenGui:Destroy()
    end
end

-- ----------------------------------------------------------------------------------------------------------------Создаем вкладку Description
local descriptionTab = MenuSystem.createTab("Description")


function MenuSystem.createDescriptionText(text, position, isTitle)
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0.95, 0, 0, isTitle and 30 or 20)
    textLabel.Position = UDim2.new(0.025, 0, 0, position)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = text
    textLabel.TextColor3 = isTitle and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
    textLabel.TextSize = isTitle and 16 or 14
    textLabel.Font = isTitle and Enum.Font.GothamBold or Enum.Font.GothamMedium
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextWrapped = true
    textLabel.Parent = descriptionTab.Frame
    return textLabel
end

-- Создаем заголовок
local titleLabel = MenuSystem.createDescriptionText("Changelog", 10, true)

-- Добавляем версии и их изменения
local versionData = {            --date = os.date("!%Y-%m-%d"),
{
    version = "Version 1.5",
    date = os.date("!%Y-%m-%d"),
    changes = {
        "Added Auto Press feature:",
        "• Automatic Q key pressing",
        "• Adjustable delay settings",
        "• Toggle with V key",
        "• Visual feedback and notifications"

}
    },
    {
        version = "Version 1.4",
        date = "2025-03-31",
        changes = {
            "Added Config System:",
            "• Save/Load settings functionality",
            "• Settings reset option",
            "• Automatic settings restore",
            "• JSON config file storage"
        }
    },
    {
        version = "Version 1.3", 
        date = "2025-03-30",
        changes = {
            "Enhanced ESP System:",
            "• Added team/enemy color differentiation",
            "• Improved color picker interface",
            "• Added ESP toggle notifications",
            "• Optimized ESP performance"
        }
    },
    {
        version = "Version 1.2",
        date = "2025-03-30",
        changes = {
            "Enhanced Notification System:",
            "• Added notification queue",
            "• Different notification types",
            "• Smooth animations",
            "• Auto-close functionality"
        }
    },
    {
        version = "Version 1.1",
        date = "2025-03-30", 
        changes = {
            "Added Game Optimization:",
            "• Texture quality reduction",
            "• Particle effect removal",
            "• Lighting optimization",
            "• Performance monitoring",
            "Enhanced Noclip:",
            "• Added keybind system",
            "• Improved collision handling"
        }
    },
    {
        version = "Version 1.0",
        date = "2025-03-30",
        changes = {
            "Initial Release:",
            "• Basic ESP functionality",
            "• Platform selector",
            "• Tab system",
            "• Basic UI elements"
        }
    },
    {
        version = "Version 0.9",
        date = "2025-03-30",
        changes = {
            --"Added Aimbot tab with advanced features:",
            "• Custom aim target selection",
            "• Player lock system",
            "• FOV circle visualization",
            "• Target prediction system",
            "• Team check option"
        }
    },
    {
        version = "Version 0.8",
        date = "2025-03-30",
        changes = {
            "Added Notification system",
            "Improved GUI responsiveness",
            "Added current time and user display",
            "Enhanced menu animations"
        }
    },
    {
        version = "Version 0.7",
        date = "2025-03-30",
        changes = {
            "Added Noclip feature",
            "Added Optimization system",
            "Improved performance",
            "Bug fixes and stability improvements"
        }
    },
    {
    version = "Version 0.6",
    date = "2025-03-30",
    changes = {
        "Added ESP features:",
        "• Toggle ESP functionality",
        "• Customizable colors for Team, Enemy, and Boxes",
        "• Color picker interface",
        "• Improved notifications for ESP settings"
    }
},
{
        version = "Version 0.2-0.5",
        date = "2025-03-30",
        changes = {
            "MENU GLOBAL SETTINGS: ADD",
            "Added Noclip feature",
            "Added Game Optimization",
            "Enhanced UI elements",
            "Performance improvements"
        }
    },
    {
        version = "Version 0.1",
        date = "2025-03-30",
        changes = {
            "Initial release",
            "Added ESP feature",
            "Added Color customization",
            "Basic menu functionality"
        }
    }
}

MenuSystem.ESPSettings = {
    Enabled = false,
    Colors = {
        Enemy = Color3.fromRGB(255, 0, 0),
        Team = Color3.fromRGB(0, 255, 0),
        Box = Color3.fromRGB(255, 255, 255)
    }
}

-- Функция для создания цветового пикера
function MenuSystem.createColorPicker(tab, position, title, defaultColor, callback)
    local pickerFrame = Instance.new("Frame")
    pickerFrame.Name = "ColorPicker_" .. title
    pickerFrame.Size = UDim2.new(0.95, 0, 0, 60)
    pickerFrame.Position = UDim2.new(0.025, 0, 0, position * (MenuSystem.ButtonHeight + MenuSystem.ButtonSpacing))
    pickerFrame.BackgroundColor3 = Colors.Button
    pickerFrame.BorderSizePixel = 0
    pickerFrame.Parent = tab.Frame

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = pickerFrame

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.7, 0, 0, 25)
    titleLabel.Position = UDim2.new(0, 10, 0, 5)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Colors.TextColor
    titleLabel.TextSize = 14
    titleLabel.Font = Enum.Font.GothamMedium
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = pickerFrame

    local colorButton = Instance.new("TextButton")
    colorButton.Size = UDim2.new(0, 40, 0, 20)
    colorButton.Position = UDim2.new(0.8, 0, 0.5, -10)
    colorButton.BackgroundColor3 = defaultColor
    colorButton.Text = ""
    colorButton.Parent = pickerFrame

    local colorCorner = Instance.new("UICorner")
    colorCorner.CornerRadius = UDim.new(0, 4)
    colorCorner.Parent = colorButton

    -- Создаем слайдеры для RGB
    local function createSlider(color, yPos)
        local slider = Instance.new("Frame")
        slider.Size = UDim2.new(0.6, 0, 0, 2)
        slider.Position = UDim2.new(0, 10, 0, yPos)
        slider.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        slider.Parent = pickerFrame

        local sliderButton = Instance.new("TextButton")
        sliderButton.Size = UDim2.new(0, 10, 0, 10)
        sliderButton.Position = UDim2.new((defaultColor[color] / 255), 0, 0.5, -5)
        sliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        sliderButton.Text = ""
        sliderButton.Parent = slider

        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(1, 0)
        buttonCorner.Parent = sliderButton

        -- Добавляем функционал перетаскивания
        local dragging = false
        sliderButton.MouseButton1Down:Connect(function() dragging = true end)
        game:GetService("UserInputService").InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)

        game:GetService("UserInputService").InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local pos = math.clamp(
                    (input.Position.X - slider.AbsolutePosition.X) / slider.AbsoluteSize.X,
                    0, 1
                )
                sliderButton.Position = UDim2.new(pos, 0, 0.5, -5)
                local newColor = Color3.new(
                    color == "R" and pos or defaultColor.R,
                    color == "G" and pos or defaultColor.G,
                    color == "B" and pos or defaultColor.B
                )
                defaultColor = newColor
                colorButton.BackgroundColor3 = newColor
                callback(newColor)
            end
        end)
    end

    createSlider("R", 30)
    createSlider("G", 40)
    createSlider("B", 50)

    return pickerFrame
end

-- Создаем кнопку Change Colors
MenuSystem.createButton("Visuals", 4, "Change Colors", function()
    -- Создаем окно настройки цветов
    local colorFrame = Instance.new("Frame")
    colorFrame.Size = UDim2.new(0, 200, 0, 250)
    colorFrame.Position = UDim2.new(0.5, -100, 0.5, -125)
    colorFrame.BackgroundColor3 = Colors.Background
    colorFrame.BorderSizePixel = 0
    colorFrame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = colorFrame

    -- Добавляем заголовок
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "ESP Colors"
    title.TextColor3 = Colors.TextColor
    title.TextSize = 16
    title.Font = Enum.Font.GothamBold
    title.Parent = colorFrame

    -- Создаем цветовые пикеры для каждого типа ESP
    local function createColorOption(name, defaultColor, yPos)
        MenuSystem.createColorPicker(colorFrame, yPos, name, defaultColor, function(newColor)
            MenuSystem.ESPSettings.Colors[name] = newColor
            -- Показываем уведомление при изменении цвета
            MenuSystem.showNotification(
                "Color Changed",
                name .. " color has been updated",
                "success"
            )
        end)
    end

    createColorOption("Enemy", MenuSystem.ESPSettings.Colors.Enemy, 1)
    createColorOption("Team", MenuSystem.ESPSettings.Colors.Team, 2)
    createColorOption("Box", MenuSystem.ESPSettings.Colors.Box, 3)

    -- Показываем уведомление
    MenuSystem.showNotification(
        "Color Settings",
        "ESP color settings opened",
        "info"
    )
end)

-- Функция для создания разделителя
function MenuSystem.createDivider()
    local divider = Instance.new("Frame")
    divider.Size = UDim2.new(0.9, 0, 0, 1)
    divider.Position = UDim2.new(0.05, 0, 0, 0)
    divider.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
    divider.BorderSizePixel = 0
    divider.Parent = descriptionTab.Frame
    return divider
end

-- Отображаем информацию о версиях
local currentPosition = 50
for _, version in ipairs(versionData) do
    -- Заголовок версии
    local versionTitle = MenuSystem.createDescriptionText(version.version, currentPosition, true)
    currentPosition = currentPosition + 35

    -- Дата версии
    local dateLabel = MenuSystem.createDescriptionText("Released: " .. version.date, currentPosition, false)
    dateLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    currentPosition = currentPosition + 25

    -- Изменения
    for _, change in ipairs(version.changes) do
        local changeLabel = MenuSystem.createDescriptionText(change, currentPosition, false)
        currentPosition = currentPosition + 20
    end

    -- Добавляем разделитель между версиями
    currentPosition = currentPosition + 10
    local divider = MenuSystem.createDivider()
    divider.Position = UDim2.new(0.05, 0, 0, currentPosition)
    currentPosition = currentPosition + 20
end

-- Добавляем информацию о текущей сессии
local sessionInfo = string.format("\nCurrent session:\nDate: %s\nUser: %s", 
    MenuSystem.getCurrentUTCTime(),
    game.Players.LocalPlayer.Name
)

local sessionLabel = MenuSystem.createDescriptionText(sessionInfo, currentPosition, false)
sessionLabel.TextColor3 = Color3.fromRGB(150, 150, 150)

-- Обновление времени в реальном времени
game:GetService("RunService").Heartbeat:Connect(function()
    if sessionLabel then
        sessionLabel.Text = string.format("\nCurrent session:\nDate: %s\nUser: %s",
            MenuSystem.getCurrentUTCTime(),
            game.Players.LocalPlayer.Name
        )
    end
end)


------------------------------------------------------------------------------------------------------------------------------









function MenuSystem.optimizeGame()
    local workspace = game:GetService("Workspace")
    local startTime = os.clock()
    local objectsRemoved = 0
    
    -- Функция для удаления объектов по их типу
    local function removeObjectsByType(parent, objectType)
        for _, obj in ipairs(parent:GetDescendants()) do
            if obj:IsA(objectType) and not obj:IsDescendantOf(game.Players.LocalPlayer.Character) then
                pcall(function()
                    obj:Destroy()
                    objectsRemoved = objectsRemoved + 1
                end)
            end
        end
    end
    
    -- Список типов объектов для удаления
    local objectTypes = {
        "ParticleEmitter",
        "Trail",
        "Smoke",
        "Fire",
        "Sparkles",
        "PointLight",
        "SpotLight",
        "SurfaceLight",
        "Decal",
        "Texture"
    }
    
    -- Удаляем объекты
    for _, objectType in ipairs(objectTypes) do
        removeObjectsByType(workspace, objectType)
    end
    
    -- Оптимизация текстур и материалов
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and not obj:IsDescendantOf(game.Players.LocalPlayer.Character) then
            pcall(function()
                obj.Material = Enum.Material.SmoothPlastic
                obj.TextureID = ""
            end)
        end
    end
    
    -- Отключение ненужных эффектов
    local lighting = game:GetService("Lighting")
    pcall(function()
        lighting.GlobalShadows = false
        lighting.FogEnd = 9e9
        lighting.Brightness = 2
    end)
    
    -- Удаление эффектов из Lighting
    for _, obj in ipairs(lighting:GetChildren()) do
        if obj:IsA("BloomEffect") or 
           obj:IsA("BlurEffect") or 
           obj:IsA("ColorCorrectionEffect") or 
           obj:IsA("SunRaysEffect") or 
           obj:IsA("DepthOfFieldEffect") then
            obj:Destroy()
            objectsRemoved = objectsRemoved + 1
        end
    end
    
    -- Настройка рендеринга
    local settings = UserSettings():GetService("UserGameSettings")
    settings.SavedQualityLevel = 1
    
    -- Вычисляем время выполнения
    local executionTime = math.floor((os.clock() - startTime) * 1000)
    
    -- Показываем уведомление с результатами
    MenuSystem.showNotification(
        "Optimization Complete",
        string.format("Removed %d objects in %dms", objectsRemoved, executionTime),
        "success"
    )
    
    -- Обновляем кнопку
    local button = MenuSystem.Tabs[3].Frame:FindFirstChild("Button_2")
    if button then
        -- Сохраняем оригинальный цвет текста
        local originalColor = button.TextColor3
        
        -- Меняем цвет и текст
        button.Text = "Optimization (Done!)"
        button.TextColor3 = Color3.fromRGB(46, 204, 113)
        
        -- Возвращаем оригинальный цвет через 2 секунды
        task.delay(2, function()
            if button and button.Parent then
                button.TextColor3 = originalColor
                button.Text = "Optimization"
            end
        end)
    end
end

-- Функция получения текущего времени UTC
function MenuSystem.getCurrentUTCTime()
    local date = os.date("!*t")
    return string.format("%04d-%02d-%02d %02d:%02d:%02d", 
        date.year, date.month, date.day, 
        date.hour, date.min, date.sec)
end

-- Функция получения имени пользователя
function MenuSystem.getCurrentUser()
    return game.Players.LocalPlayer.Name
end

-- Обновляем создание кнопки оптимизации
MenuSystem.createButton("Misc", 2, "Optimization", function()
    -- Добавляем подтверждение перед оптимизацией
    local confirmed = true -- Можно добавить диалог подтверждения если нужно
    
    if confirmed then
        MenuSystem.showNotification(
            "Starting Optimization",
            "Please wait while we optimize the game...",
            "info"
        )
        
        -- Небольшая задержка перед началом оптимизации
        task.delay(0.5, function()
            MenuSystem.optimizeGame()
        end)
    end
end)














-- Добавляем вкладку Config
local configTab = MenuSystem.createTab("Config")

-- Создаем хранилище настроек
MenuSystem.Settings = {
    ESP = {
        Enabled = false,
        Colors = MenuSystem.ESP_CONFIG or {
            HIGHLIGHT_COLOR = Color3.fromRGB(136, 155, 155),
            TEXT_COLOR = Color3.fromRGB(136, 155, 155),
            TEXT_STROKE_COLOR = Color3.fromRGB(0, 0, 0)
        }
    },
    Noclip = {
        Enabled = false,
        KeyBind = Enum.KeyCode.X
    },
    Optimization = {
        LastOptimized = 0,
        AutoOptimize = false
    },
    Interface = {
        Theme = {
            Background = Colors.Background,
            Button = Colors.Button,
            ButtonHover = Colors.ButtonHover,
            AccentColor = Colors.AccentColor,
            TextColor = Colors.TextColor
        }
    }
}

-- Функция сохранения настроек
function MenuSystem.saveSettings()
    local success, encoded = pcall(function()
        local settings = {
            ESP = {
                Enabled = MenuSystem.wallhackEnabled,
                Colors = {
                    HIGHLIGHT_COLOR = {
                        R = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.R,
                        G = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.G,
                        B = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR.B
                    },
                    TEXT_COLOR = {
                        R = MenuSystem.ESP_CONFIG.TEXT_COLOR.R,
                        G = MenuSystem.ESP_CONFIG.TEXT_COLOR.G,
                        B = MenuSystem.ESP_CONFIG.TEXT_COLOR.B
                    }
                }
            },
            Noclip = {
                Enabled = MenuSystem.noclipEnabled,
                KeyBind = tostring(Enum.KeyCode.X)
            },
            Optimization = MenuSystem.Settings.Optimization
        }
        return game:GetService("HttpService"):JSONEncode(settings)
    end)

    if success then
        writefile("MenuSystem_Settings.json", encoded)
        MenuSystem.showNotification(
            "Settings Saved",
            "Your settings have been saved successfully",
            "success"
        )
    else
        MenuSystem.showNotification(
            "Save Error",
            "Failed to save settings",
            "error"
        )
    end
end

-- Функция загрузки настроек
function MenuSystem.loadSettings()
    if isfile("MenuSystem_Settings.json") then
        local success, decoded = pcall(function()
            local data = readfile("MenuSystem_Settings.json")
            return game:GetService("HttpService"):JSONDecode(data)
        end)

        if success then
            -- Применяем загруженные настройки ESP
            if decoded.ESP then
                MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR = Color3.new(
                    decoded.ESP.Colors.HIGHLIGHT_COLOR.R,
                    decoded.ESP.Colors.HIGHLIGHT_COLOR.G,
                    decoded.ESP.Colors.HIGHLIGHT_COLOR.B
                )
                MenuSystem.ESP_CONFIG.TEXT_COLOR = Color3.new(
                    decoded.ESP.Colors.TEXT_COLOR.R,
                    decoded.ESP.Colors.TEXT_COLOR.G,
                    decoded.ESP.Colors.TEXT_COLOR.B
                )
                
                if decoded.ESP.Enabled then
                    MenuSystem.toggleESP()
                end
            end

            -- Применяем настройки Noclip
            if decoded.Noclip and decoded.Noclip.Enabled then
                MenuSystem.toggleNoclip()
            end

            -- Применяем настройки к существующим ESP объектам
            for _, objects in pairs(MenuSystem.espObjects) do
                if objects.highlight then
                    objects.highlight.FillColor = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR
                    objects.highlight.OutlineColor = MenuSystem.ESP_CONFIG.HIGHLIGHT_COLOR
                end
                if objects.billboard then
                    local nameLabel = objects.billboard:FindFirstChild("TextLabel")
                    if nameLabel then
                        nameLabel.TextColor3 = MenuSystem.ESP_CONFIG.TEXT_COLOR
                    end
                end
            end

            MenuSystem.showNotification(
                "Settings Loaded",
                "Your settings have been restored",
                "success"
            )
        else
            MenuSystem.showNotification(
                "Load Error",
                "Failed to load settings",
                "error"
            )
        end
    end
end

-- Создаем кнопки в Config табе
MenuSystem.createButton("Config", 1, "Save Settings", function()
    MenuSystem.saveSettings()
end)

MenuSystem.createButton("Config", 2, "Load Settings", function()
    MenuSystem.loadSettings()
end)

MenuSystem.createButton("Config", 3, "Reset Settings", function()
    if isfile("MenuSystem_Settings.json") then
        delfile("MenuSystem_Settings.json")
    end
    
    -- Сбрасываем ESP настройки
    MenuSystem.ESP_CONFIG = {
        HIGHLIGHT_COLOR = Color3.fromRGB(136, 155, 155),
        TEXT_COLOR = Color3.fromRGB(136, 155, 155),
        TEXT_STROKE_COLOR = Color3.fromRGB(0, 0, 0),
        TEXT_SIZE = 15,
        BILLBOARD_OFFSET = Vector3.new(0, 2.5, 0)
    }
    
    -- Отключаем ESP и Noclip если они были включены
    if MenuSystem.wallhackEnabled then
        MenuSystem.toggleESP()
    end
    
    if MenuSystem.noclipEnabled then
        MenuSystem.toggleNoclip()
    end
    
    MenuSystem.showNotification(
        "Settings Reset",
        "All settings have been reset to default",
        "info"
    )
end)

-- Добавляем автозагрузку настроек при запуске
MenuSystem.loadSettings()











-- Добавляем настройки автонажатия
MenuSystem.AutoPressSettings = {
    Enabled = false,
    Key = "Q",
    Delay = 0, -- Задержка между нажатиями в секундах
    Connection = nil
}

-- Функция для симуляции нажатия клавиши
function MenuSystem.startAutoPress()
    if MenuSystem.AutoPressSettings.Connection then
        MenuSystem.AutoPressSettings.Connection:Disconnect()
        MenuSystem.AutoPressSettings.Connection = nil
    end

    -- Создаем новое соединение для автонажатия
    MenuSystem.AutoPressSettings.Connection = game:GetService("RunService").Heartbeat:Connect(function()
        if MenuSystem.AutoPressSettings.Enabled then
            local virtualInputManager = game:GetService("VirtualInputManager")
            
            -- Симулируем нажатие клавиши Q
            virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
            task.wait(0.000000000001) -- Небольшая задержка между нажатием и отпусканием
            virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
            
            task.wait(MenuSystem.AutoPressSettings.Delay) -- Задержка между нажатиями
        end
    end)
end

-- Создаем кнопку Auto Press Q
MenuSystem.createButton("Game", 1, "Auto Press Q", function()
    MenuSystem.AutoPressSettings.Enabled = not MenuSystem.AutoPressSettings.Enabled
    
    -- Обновляем текст кнопки
    local button = MenuSystem.Tabs[3].Frame:FindFirstChild("Button_3")
    if button then
        button.Text = "Auto Press Q: " .. (MenuSystem.AutoPressSettings.Enabled and "ON" or "OFF")
        button.TextColor3 = MenuSystem.AutoPressSettings.Enabled and Color3.fromRGB(0, 255, 0) or Colors.TextColor
    end
    
    if MenuSystem.AutoPressSettings.Enabled then
        MenuSystem.startAutoPress()
        
        -- Показываем уведомление о включении
        MenuSystem.showNotification(
            "Auto Press Enabled",
            "Automatically pressing Q key",
            "success"
        )
    else
        if MenuSystem.AutoPressSettings.Connection then
            MenuSystem.AutoPressSettings.Connection:Disconnect()
            MenuSystem.AutoPressSettings.Connection = nil
        end
        
        -- Показываем уведомление о выключении
        MenuSystem.showNotification(
            "Auto Press Disabled",
            "Stopped pressing Q key",
            "info"
        )
    end
end)

-- Создаем слайдер для настройки задержки
MenuSystem.createSlider("Game", 2, "Auto Press Delay", 0.1, 2, MenuSystem.AutoPressSettings.Delay, function(value)
    MenuSystem.AutoPressSettings.Delay = value
    
    -- Показываем уведомление об изменении задержки
    MenuSystem.showNotification(
        "Delay Updated",
        string.format("Auto press delay set to %.2f seconds", value),
        "info"
    )
end)

-- Функция для получения ближайшего игрока в поле зрения
local function getClosestPlayerInFOV()
    local player = game.Players.LocalPlayer
    local camera = game.Workspace.CurrentCamera
    local closestPlayer = nil
    local closestAngle = math.rad(70) -- FOV в радианах (70 градусов)
    local closestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and 
           otherPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           otherPlayer.Character:FindFirstChild("Humanoid") and 
           otherPlayer.Character.Humanoid.Health > 0 then
            
            local targetPos = otherPlayer.Character.HumanoidRootPart.Position
            local screenPoint = camera:WorldToScreenPoint(targetPos)
            
            -- Проверяем, находится ли игрок в поле зрения
            if screenPoint.Z > 0 then
                local centerScreen = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                local screenPos = Vector2.new(screenPoint.X, screenPoint.Y)
                local angle = math.atan2(screenPos.Y - centerScreen.Y, screenPos.X - centerScreen.X)
                
                if math.abs(angle) < closestAngle then
                    local distance = (targetPos - player.Character.HumanoidRootPart.Position).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = otherPlayer
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Функция для выполнения искривленного dash
local function performCurvedDash()
    local player = game.Players.LocalPlayer
    local target = getClosestPlayerInFOV()
    
    if target and target.Character then
        -- Получаем позиции
        local startPos = player.Character.HumanoidRootPart.Position
        local targetPos = target.Character.HumanoidRootPart.Position
        
        -- Вычисляем направление за спину цели
        local targetLook = target.Character.HumanoidRootPart.CFrame.LookVector
        local behindPos = targetPos - (targetLook * 5) -- 5 единиц за спиной
        
        -- Создаем точки для искривленной траектории
        local midPoint = (startPos + behindPos) * 0.5
        midPoint = midPoint + Vector3.new(0, 10, 0) -- Поднимаем среднюю точку вверх
        
        -- Выполняем dash
        local args = {
            [1] = {
                Bool = false,
                Request = "FrontDash",
                Target = behindPos,
                Curve = {
                    startPos,
                    midPoint,
                    behindPos
                }
            }
        }
        
        game:GetService("Workspace").Characters.CmeTanKa_Gaben.Network:FireServer(unpack(args))
        
        -- Показываем уведомление
        MenuSystem.showNotification(
            "Curved Dash",
            "Performed curved dash behind " .. target.Name,
            "success"
        )
    else
        -- Уведомление, если цель не найдена
        MenuSystem.showNotification(
            "Dash Failed",
            "No valid target in FOV",
            "error"
        )
    end
end

-- Создаем кнопку для Curved Dash
MenuSystem.createButton("Game", 2, "Curved Dash", function()
    performCurvedDash()
end)











-- Обновление информации о времени и пользователе
if MenuSystem.dateTimeLabel then
    -- Обновляем время каждую секунду
    game:GetService("RunService").Heartbeat:Connect(function()
        MenuSystem.dateTimeLabel.Text = MenuSystem.getCurrentUTCTime()
    end)
end

if MenuSystem.userLabel then
    MenuSystem.userLabel.Text = "User: " .. MenuSystem.getCurrentUser()
end



return MenuSystem
    -- ... остальной код меню
end



























































-- Функция загрузки мобильной версии
function loadMobileVersion()



    -- Создаем мобильную кнопку и меню
    local mobileButton = Instance.new("ImageButton")
    -- ... код мобильной версии

    local mobileButton = Instance.new("ImageButton")
    mobileButton.Name = "MobileMenuButton"
    mobileButton.Size = UDim2.new(0, 50, 0, 50)
    mobileButton.Position = UDim2.new(0.1, 0, 0.5, -25)
    mobileButton.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    mobileButton.Image = "rbxassetid://3926307971" -- ID иконки меню
    mobileButton.ImageRectOffset = Vector2.new(404, 844)
    mobileButton.ImageRectSize = Vector2.new(36, 36)
    mobileButton.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui")

    -- Скругление углов кнопки
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 25)
    buttonCorner.Parent = mobileButton

    -- Тень для кнопки
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.Size = UDim2.new(1.2, 0, 1.2, 0)
    shadow.ZIndex = -1
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.Parent = mobileButton

    -- Делаем кнопку перетаскиваемой
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    mobileButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mobileButton.Position
        end
    end)

    mobileButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and dragging then
            local delta = input.Position - dragStart
            mobileButton.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)

    mobileButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    -- Обработка нажатия на кнопку
    local menuVisible = false
    mobileButton.MouseButton1Click:Connect(function()
        menuVisible = not menuVisible
        if menuVisible then
            -- Показываем меню
            mainFrame.Visible = true
            game:GetService("TweenService"):Create(mainFrame, TweenInfo.new(0.3), {
                Position = UDim2.new(0.5, -275, 0.5, -175)
            }):Play()
        else
            -- Скрываем меню
            game:GetService("TweenService"):Create(mainFrame, TweenInfo.new(0.3), {
                Position = UDim2.new(1.5, 0, 0.5, -175)
            }):Play()
            wait(0.3)
            mainFrame.Visible = false
        end
    end)
end

-- Запускаем селектор платформы
createPlatformSelector()
